# 网络并发重点代码

[TOC]

##### 1 基于udp套接字的编程



```python
"""
udp套接字服务端程序示例

重点代码 ！！！
"""
from socket import *

# 创建udp套接字
udp_socket = socket(AF_INET,SOCK_DGRAM)

# 绑定地址
udp_socket.bind(('0.0.0.0',8888))

# 接收消息
while True:
    data,addr = udp_socket.recvfrom(1024)
    # 收到exit结束 服务端程序可以一直运行
    # if data == b"exit":
    #     break

    print("From",addr,":",data.decode())
    # 发送消息
    n = udp_socket.sendto(b"Thanks",addr) # 发送字节串
    print("Send %d bytes"%n)

# 关闭套接字
udp_socket.close()


```



```python
"""
udp 客户端
重点代码 ！！！
"""
from socket import *

# 服务器地址
ADDR = ("127.0.0.1",8888)

# 创建udp套接字
udp_socket = socket(AF_INET,SOCK_DGRAM)

# 发送后接收，与服务端配合
while True:
    msg = input(">>")
    # 直接回车退出，不用管服务器
    if not msg:
        break
    udp_socket.sendto(msg.encode(),ADDR) # 发送字节串
    # 输入exit结束循环
    # if msg == 'exit':
    #     break
    data,addr = udp_socket.recvfrom(1024)
    print("From server:",data.decode())

# 关闭套接字
udp_socket.close()
```



##### 2 基于tcp的编程



```python
"""
tcp 服务端基础实例

重点代码 ！！
"""

from socket import *
import time

# 创建tcp套接字
tcp_socket = socket(AF_INET,SOCK_STREAM)

# 绑定地址
tcp_socket.bind(('0.0.0.0',8888))

# 设置监听
tcp_socket.listen(5)

while True:
    # 处理客户端链接 (阻塞函数)
    print("Waiting for connect...")
    connfd,addr = tcp_socket.accept()
    print("Connect from",addr)

    # 收发消息
    while True:
        # 链接的另外一端结束 此时 recv会返回空字节串
        data = connfd.recv(5)
        # 收到##或者data为空字节串时 表示客户端结束
        if not data or data == b"##":
            break

        print("接收到：",data.decode())

        connfd.send(b"Thanks")
        time.sleep(0.1)

    connfd.close()

# 关闭套接字
tcp_socket.close()



```



```python
"""
tcp客户端基础实例
重点代码
"""

from socket import *

# 创建tcp套接字 默认就是tcp套接字
tcp_socket = socket()

# 发起链接
tcp_socket.connect(('127.0.0.1',8888))

# 收发消息
while True:
    msg = input(">>")
    if not msg:
        break
    tcp_socket.send(msg.encode())

    # 客户端退出，先告知服务端
    # if msg == "##":
    #     break

    data = tcp_socket.recv(1024)
    print("From server:",data.decode())

# 关闭套接字
tcp_socket.close()


```



```python
"""
tcp 套接字示例
服务端可以 为 多个客户端服务

重点代码！！
"""

from socket import *

# 创建tcp套接字
tcp_socket = socket(AF_INET,SOCK_STREAM)

# 绑定地址
tcp_socket.bind(('0.0.0.0',8888))

# 设置监听
tcp_socket.listen(5)

while True:
    # 处理客户端链接 (阻塞函数)
    print("Waiting for connect...")
    connfd,addr = tcp_socket.accept()
    # 收发消息
    data = connfd.recv(1024)
    print("接收到：",data.decode())
    connfd.send(b"Thanks")
    connfd.close()

# 关闭套接字
tcp_socket.close()
```



```python
"""
tcp客户端示例2
多个客户端循环发送消息

重点代码！！
"""
from socket import *

# 循环发送消息
# 每次发送消息都需要重新建立套接字，发起链接，效率较低
while True:
    msg = input(">>")
    if not msg:
        break

    # 创建套接字，完成一次消息的收发后就关闭
    tcp_socket = socket()
    tcp_socket.connect(('127.0.0.1',8888))
    tcp_socket.send(msg.encode())
    data = tcp_socket.recv(1024)
    print("from Server：",data.decode())
    tcp_socket.close()
```

##### 3 http格式

```python
"""
练习 : 将 first.html作为一个要展示的网页
当用户的请求内容是 /first.html的时候则将这个
网页内容作为一个响应体提供给浏览器

如果浏览器请求的是其他内容则 返回一个404的响应,
内容自定

要求浏览器可以循环的访问

思路 : 1 服务端循环模型
      2. 接收到请求后要提取请求内容
      3. 根据请求内容分情况讨论
"""
from socket import *

HOST = "0.0.0.0"
PORT = 8000
ADDR = (HOST,PORT)

# 创建tcp网络
sockfd = socket()
sockfd.bind(ADDR)
sockfd.listen(5)

while True:
    connfd,addr = sockfd.accept()
    # 接收http请求
    request = connfd.recv(1024).decode()
    # 防止返回值为空
    if not request:
        continue

    # 提取出请求内容
    info = request.split(' ')[1]
    print("请求内容:",info)

    if info == '/first.html':
        response = "HTTP/1.1 200 OK\r\n"
        response += "Content-Type:text/html\r\n"
        response += "\r\n"
        with open('first.html') as f:
            response += f.read()
    else:
        response = "HTTP/1.1 404 Not Found\r\n"
        response += "Content-Type:text/html\r\n"
        response += "\r\n"
        response += "<h1>Sorry.....</h1>"

    # 发送响应
    connfd.send(response.encode())

```



##### 4 基于多进程的tcp网络并发模型

```python
"""
基于多进程的tcp网络并发模型
    创建网络套接字用于接收客户端请求
    等待客户端连接
    客户端连接，则创建新的进程具体处理客户端请求
    主进程继续等待其他客户端连接
    如果客户端退出，则销毁对应的进程

重点代码 !!!
"""
from multiprocessing import Process
from socket import *
from signal import *
import sys

# 网络地址
HOST = '0.0.0.0'
PORT = 8888
ADDR = (HOST,PORT)

# 处理客户端事件
def handle(connfd):
    while True:
        data = connfd.recv(1024)
        if not data:
            break
        print(data.decode())
        connfd.send(b'ok')
    connfd.close()

# 搭建并发网络
def main():
    # 创建tcp套接字
    sock = socket()
    sock.bind(ADDR)
    sock.listen(5)

    print("Listen the port %d"%PORT)
    signal(SIGCHLD,SIG_IGN) # 处理僵尸进程

    # 循环等待客户端链接
    while True:
        try:
            connfd,addr = sock.accept()
            print("Connect from",addr)
        except KeyboardInterrupt:
            sys.exit("服务结束")

        # 为连接进来的客户端创建新的进程
        p = Process(target=handle,args=(connfd,))
        p.daemon = True # 子进程随父进程退出
        p.start()

if __name__ == '__main__':
    main()


```



##### 5 基于多线程的tcp网络并发模型

```python
"""
基于多线程的tcp并发模型

重点代码 !!
"""

from threading import Thread
from socket import *
import sys

# 网络地址
HOST = '0.0.0.0'
PORT = 8888
ADDR = (HOST,PORT)

# 类用于处理客户端的事件
class MyThread(Thread):
    def __init__(self,connfd):
        # 客户端链接套接字设置为属性
        self.connfd = connfd
        super().__init__()

    # 处理客户端事件
    def run(self):
        while True:
            data = self.connfd.recv(1024)
            if not data:
                break
            print(data.decode())
            self.connfd.send(b'ok')
        self.connfd.close()

# 搭建并发网络
def main():
    # 创建tcp套接字
    sock = socket()
    sock.bind(ADDR)
    sock.listen(5)

    print("Listen the port %d"%PORT)

    # 循环等待客户端链接
    while True:
        try:
            connfd,addr = sock.accept()
            print("Connect from",addr)
        except KeyboardInterrupt:
            sys.exit("服务结束")

        # 为连接进来的客户端创建新的线程
        t = MyThread(connfd)
        t.setDaemon(True)
        t.start()

if __name__ == '__main__':
    main()
```



##### 6 基于 select 方法的IO多路复用并发模型

```python
"""
基于 select 方法的IO多路复用并发模型

重点代码 !!
"""
from socket import *
from select import select

# 创建监听套接字,作为初始监控对象
sockfd = socket()
sockfd.bind(('0.0.0.0',8888))
sockfd.listen(5)

# 设置为非阻塞
sockfd.setblocking(False)

# 设置关注列表
rlist = [sockfd] # 关注监听套接字
wlist = []
xlist = []

# 循环监控关注的IO
while True:
    rs,ws,xs = select(rlist,wlist,xlist)
    # 遍历就绪的IO列表,分情况讨论 监听套接字和客户端连接套接字
    for r in rs:
        if r is sockfd:
            connfd, addr = r.accept()
            print("Connect from",addr)
            # 将链接进来的客户端链接套接字加入关注的IO
            connfd.setblocking(False)
            rlist.append(connfd)
        else:
            # 某个客户端发送了消息
            data = r.recv(1024).decode()
            if not data:
                # 客户端结束
                rlist.remove(r) # 取消关注
                r.close()
                continue # for循环继续遍历后面的IO
            print(data)
            # r.send(b'OK')
            wlist.append(r) # 加入到写关注列表

    for w in ws:
        w.send(b'ok')
        wlist.remove(w) # 移除

```



##### 7 基于 epoll 方法的IO多路复用并发模型

```python
"""
基于 epoll 方法的IO多路复用并发模型

重点代码　！！
"""
from socket import *
from select import *

# 创建监听套接字,作为初始监控对象
sockfd = socket()
sockfd.bind(('0.0.0.0', 8888))
sockfd.listen(5)

# 设置为非阻塞
sockfd.setblocking(False)

# epoll对象
ep = epoll()

# 查找字典 {fileno:sockfd} 与关注的IO保持一致
map = {sockfd.fileno(): sockfd}
# 关注监听套接字
ep.register(sockfd, EPOLLIN)

# 循环监控关注的IO
while True:
    events = ep.poll()  # events->[(1,2)]
    print("你有新的IO需要处理哦", events)
    # 遍历就绪的IO列表,分情况讨论 监听套接字和客户端连接套接字
    for fd, event in events:
        if fd == sockfd.fileno():
            connfd, addr = map[fd].accept()
            print("Connect from", addr)
            # 将链接进来的客户端链接套接字加入关注
            connfd.setblocking(False)
            # 设置为边缘触发
            ep.register(connfd, EPOLLIN | EPOLLET)
            # 字典也要维护
            map[connfd.fileno()] = connfd
        elif event == EPOLLIN:
            # 某个客户端发送了消息
            data = map[fd].recv(1024).decode()
            if not data:
                # 客户端结束
                ep.unregister(fd)  # 取消关注
                map[fd].close()
                del map[fd]  # 从字典中移除
                continue  # for循环继续遍历后面的IO
            print(data)
            # map[fd].send(b'OK')
            ep.unregister(fd)
            ep.register(fd, EPOLLOUT)
        elif event == POLLOUT:
            map[fd].send(b'OK')
            ep.unregister(fd)
            ep.register(fd, EPOLLIN)

```



##### 8 聊天室

###### 8.1 chat_server

```python
"""
Author: Levi
Email: lvze@tedu.cn
Time : 2020-9-12
Env: Python 3.6
socket and Process exercise
"""
from socket import *
from multiprocessing import Process

# 服务器地址
HOST = "0.0.0.0"
PORT = 8000
ADDR = (HOST, PORT)

# 存储用户地址信息 {name : address}
user = {}

# 处理进入聊天室
def do_login(sock,name,addr):
    if name in user or '管理' in name:
        sock.sendto(b"FAIL",addr)
        return
    else:
        sock.sendto(b"OK", addr)
        # 通知其他人
        msg = "欢迎 %s 进入聊天室"%name
        for i in user:
            sock.sendto(msg.encode(),user[i])
        user[name] = addr # 加入这个人
        # print(user) # 测试

# 处理聊天
def do_chat(sock,name,content):
    msg = "%s : %s"%(name,content)
    for i in user:
        # 除去本人
        if i != name:
            sock.sendto(msg.encode(),user[i])

# 用户退出
def do_exit(sock,name):
    del user[name] # 删除用户
    msg = "%s 退出了群聊"%name
    # 告知其他人
    for i in user:
        sock.sendto(msg.encode(), user[i])

# 子进程函数
def handle(sock):
    # 循环等待接收请求  (总分处理模式)
    while True:
        # 所有请求都在这接收
        data, addr = sock.recvfrom(1024)
        # 将客户端请你去做简单的分割处理
        tmp = data.decode().split(' ', 2)
        # 根据请求选择功能
        if tmp[0] == "L":
            # tmp--> [L,name]
            do_login(sock, tmp[1], addr)
        elif tmp[0] == 'C':
            # tmp --> [C,name,xxxxxx]
            do_chat(sock, tmp[1], tmp[2])
        elif tmp[0] == 'E':
            # tmp--> [E,name]
            do_exit(sock, tmp[1])

# 框架 启动函数
def main():
    sock = socket(AF_INET, SOCK_DGRAM)
    sock.bind(ADDR)

    p = Process(target = handle,args=(sock,))
    p.start()

    # 父进程发送管理员消息
    while True:
        content = input("管理员消息:")
        msg = "C 管理员消息 " + content
        # 从父进程发送给了子进程
        sock.sendto(msg.encode(),ADDR)


if __name__ == '__main__':
    main()

```



###### 8.2 chat_client

```python
"""
聊天室客户端
"""
from socket import *
from multiprocessing import Process
import sys

# 服务器地址
ADDR = ('124.70.133.135', 8000)


# 进入聊天室
def login(sock):
    while True:
        name = input("请输入姓名:")
        # 发送请求
        msg = "L " + name
        sock.sendto(msg.encode(), ADDR)
        # 等待回复
        data, addr = sock.recvfrom(1024)
        # 根据情况处理
        if data.decode() == 'OK':
            print("您已进入聊天室")
            return name
        else:
            print("该用户已存在")


# 接收消息
def recv_msg(sock):
    while True:
        # 服务端的所有消息都在这接收
        data, addr = sock.recvfrom(1024 * 10)
        msg = "\n" + data.decode() + "\n发言:"
        print(msg,end='')


# 发送消息
def send_msg(sock, name):
    while True:
        try:
            content = input("发言:")
        except KeyboardInterrupt:
            content = "exit"
        # 输入exit表示退出聊天室
        if content == 'exit':
            msg = "E " + name
            sock.sendto(msg.encode(), ADDR)
            sys.exit("您已退出聊天室")

        msg = "C %s %s" % (name, content)
        sock.sendto(msg.encode(), ADDR)


# 流程控制函数
def main():
    sock = socket(AF_INET, SOCK_DGRAM)
    sock.bind(('0.0.0.0',55555)) # 保证客户端地址不变

    # 进入聊天室
    name = login(sock)

    # 创建子进程
    p = Process(target=recv_msg, args=(sock,))
    p.daemon = True  # 子进程随父进程退出
    p.start()
    send_msg(sock, name)  # 发送消息


if __name__ == '__main__':
    main()

```



##### 9 FTP文件服务器

###### 9.1 ftp_server

```python
"""
ftp 文件服务器 服务端
多线程tcp并发模型
"""

from threading import Thread
from socket import *
import sys, os
import time

# 网络地址
HOST = '0.0.0.0'
PORT = 8880
ADDR = (HOST, PORT)

# 文件库位置
FTP = "/home/tarena/FTP/"


# 类用于处理客户端的事件
class FTPServer(Thread):
    def __init__(self, connfd):
        # 客户端链接套接字设置为属性
        self.connfd = connfd
        super().__init__()

    def do_list(self):
        # 判断文件库是否为空
        file_list = os.listdir(FTP)
        if not file_list:
            self.connfd.send(b'FAIL')
            return
        else:
            self.connfd.send(b'OK')
            time.sleep(0.1)  # 防止粘包
            # 使用\n做消息边界,拼接文件列表
            data = '\n'.join(file_list)
            self.connfd.send(data.encode())

    # 处理上传
    def do_stor(self, filename):
        if os.path.exists(FTP + filename):
            self.connfd.send(b"FAIL")
            return
        else:
            self.connfd.send(b"OK")
            # 接收文件
            file = open(FTP + filename, 'wb')
            while True:
                data = self.connfd.recv(1024)
                if data == b'##':
                    break
                file.write(data)
            file.close()

    # 处理下载
    def do_retr(self, filename):
        try:
            file = open(FTP + filename, 'rb')
        except:
            # 文件不存在
            self.connfd.send(b'FAIL')
            return
        else:
            self.connfd.send(b'OK')
            time.sleep(0.1)
            while True:
                data = file.read(1024 * 10)
                if not data:
                    break
                self.connfd.send(data)
            # 表示文件已经发送结束
            time.sleep(0.1)
            self.connfd.send(b'##')
            file.close()

    # 处理客户端事件
    def run(self):
        # 总分 接收某一个客户端各种请求分情况处理
        while True:
            data = self.connfd.recv(1024).decode()
            if not data or data == "EXIT":
                break
            elif data == 'LIST':
                self.do_list()
            elif data[:4] == 'STOR':
                # "STOR filename"
                filename = data.split(' ')[-1]
                self.do_stor(filename)
            elif data[:4] == 'RETR':
                # "RETR filename"
                filename = data.split(' ')[-1]
                self.do_retr(filename)

        self.connfd.close()


# 搭建并发网络
def main():
    # 创建tcp套接字
    sock = socket()
    sock.bind(ADDR)
    sock.listen(5)

    print("Listen the port %d" % PORT)

    # 循环等待客户端链接
    while True:
        try:
            connfd, addr = sock.accept()
            print("Connect from", addr)
        except KeyboardInterrupt:
            sys.exit("服务结束")

        # 为连接进来的客户端创建新的线程
        t = FTPServer(connfd)
        t.setDaemon(True)
        t.start()


if __name__ == '__main__':
    main()

```



###### 9.2 ftp_client

```python
"""
ftp 文件服务器 客户端
"""
from socket import *
from time import sleep
import sys

# 服务端地址
ADDR = ('127.0.0.1', 8880)


# 具体与服务端进行交互的类
class FTPClient:
    def __init__(self, sock):
        self.sock = sock

    def do_list(self):
        self.sock.send(b'LIST')
        # 等待回复
        result = self.sock.recv(128).decode()
        # 根据回复分情况应对
        if result == 'OK':
            # 接收文件列表
            files = self.sock.recv(1024 * 1024)
            print(files.decode())
        else:
            print("文件库为空")

    # 上传文件
    def do_stor(self, filename):
        # 本地判断文件是否存在
        try:
            file = open(filename, 'rb')
        except:
            print("文件不存在")
            return

        # 提取文件名
        filename = filename.split('/')[-1]
        # 发送请求
        msg = "STOR " + filename
        self.sock.send(msg.encode())
        # 等待反馈
        result = self.sock.recv(128).decode()
        # 分情况讨论
        if result == 'OK':
            while True:
                data = file.read(1024 * 10)
                if not data:
                    break
                self.sock.send(data)
            # 表示文件已经发送结束
            sleep(0.1)
            self.sock.send(b'##')
            file.close()
        else:
            print("文件已存在")

    # 下载文件
    def do_retr(self, filename):
        # 发送请求
        msg = "RETR " + filename
        self.sock.send(msg.encode())
        # 等待回复
        result = self.sock.recv(128).decode()
        if result == 'OK':
            file = open(filename, 'wb')
            while True:
                data = self.sock.recv(1024)
                if data == b'##':
                    break
                file.write(data)
            file.close()
        else:
            print("文件不存在")

    # 退出
    def do_exit(self):
        self.sock.send(b'EXIT')
        self.sock.close()
        sys.exit("谢谢使用")


def main():
    # 链接服务器
    sock = socket()
    sock.connect(ADDR)

    # 实例化对象,用于调用类中的具体方法发起请求
    ftp = FTPClient(sock)

    while True:
        print("\n====== 命令选项 ======")
        print("***     list         ***")
        print("***   stor filename  ***")
        print("***   retr filename  ***")
        print("***     exit         ***")
        print("========================")

        cmd = input("请输入命令:")
        if cmd == "list":
            ftp.do_list()
        elif cmd[:4] == "stor":
            # 提取文件名
            filename = cmd.split(' ')[-1]
            ftp.do_stor(filename)
        elif cmd[:4] == "retr":
            # 提取文件名
            filename = cmd.split(' ')[-1]
            ftp.do_retr(filename)
        elif cmd == 'exit':
            ftp.do_exit()
        else:
            print("请输入正确指令")


if __name__ == '__main__':
    main()

```





##### 10 Web服务器

```python
"""
web server

完成一个类,提供给别人
让他能够用这个类快速的搭建后端web服务

IO多路复用和http训练
"""
from socket import *
from select import select
import re

# 实现具体功能的类
class WebServer:
    def __init__(self,host="0.0.0.0",port=80,html=None):
        self.host = host
        self.port = port
        self.html = html
        self.rlist = []
        self.wlist = []
        self.xlist = []
        self.create_socket()
        self.bind()

    # 创建套接字
    def create_socket(self):
        self.sock = socket()
        self.sock.setblocking(False)

    def bind(self):
        self.address = (self.host,self.port)
        self.sock.bind(self.address)

    # 启动服务
    def start(self):
        self.sock.listen(5)
        print("Listen the port %d"%self.port)
        # 首先加入监听套接字
        self.rlist.append(self.sock)
        # 循环监控IO发生
        while True:
            rs,ws,xs = select(self.rlist,self.wlist,self.xlist)
            for r in rs:
                if r is self.sock:
                    # 浏览器链接
                    connfd,addr = self.sock.accept()
                    connfd.setblocking(False)
                    self.rlist.append(connfd)
                else:
                    # 处理客户端http请求
                    try:
                        self.handle(r)
                    except:
                        self.rlist.remove(r)
                        r.close()

    # 处理客户端请求
    def handle(self,connfd):
        # 浏览器发过来请求
        request = connfd.recv(1024).decode()
        # print(request)

        # 解析请求 (请求内容)
        pattern = r"[A-Z]+\s+(?P<info>/\S*)"
        result = re.match(pattern,request)
        if result:
            # 提取请求内容
            info = result.group("info")
            print("请求内容:",info)
            self.send_response(connfd,info)
        else:
            # 没有匹配到内容
            self.rlist.remove(connfd)
            connfd.close()
            return

    # 组织发送响应
    def send_response(self,connfd,info):
        # 组织文件路径
        if info == '/':
            filename = self.html + "/index.html"
        else:
            filename = self.html + info

        # 打开失败说明文件不存在
        try:
            file = open(filename,'rb')
        except:
            response = "HTTP/1.1 404 Not Found\r\n"
            response += "Content-Type:text/html\r\n"
            response += "\r\n"
            response += "<h1>Sorry.....</h1>"
            response = response.encode()
        else:
            data = file.read()
            response = "HTTP/1.1 200 OK\r\n"
            response += "Content-Type:text/html\r\n"
            response += "Content-Length:%d\r\n"%(len(data))
            response += "\r\n"
            response = response.encode() + data
        finally:
            # 发送响应给客户端
            connfd.send(response)


if __name__ == '__main__':
    # 1.使用者怎么利用这个类
    # 2.实现类的功能需要使用者提供什么(传参)
    #      地址     网页
    httpd = WebServer(host='0.0.0.0',port=8000,html='./static')
    httpd.start()


```



##### 11 在线词典

###### 11.1 两个界面怎么相互跳转

```python
"""
两个界面怎么相互跳转
"""

def login():
    # 二级界面
    while True:
        print("\n=========== 查词界面 ============")
        print(" 1.查单词   2.历史记录   3.注销")
        print("================================")

        cmd = input("请输入命令:")
        if cmd == "1":
            pass
        elif cmd == "2":
            pass
        elif cmd == "3":
            break
        else:
            print("请输入正确指令")

while True:
    print("\n======== 登录界面 =========")
    print(" 1.注册   2.登录   3.退出")
    print("==========================")

    cmd = input("请输入命令:")
    if cmd == "1":
        pass
    elif cmd == "2":
        login()
    elif cmd == "3":
        pass
    else:
        print("请输入正确指令")


```



###### 11.2 dict_server

```python
"""
dict 服务端

* 接收请求
* 处理逻辑
* 给客户端反馈内容
"""

from socket import *
from multiprocessing import Process
from signal import *
import sys
from dict_db import *
from time import sleep

HOST = "0.0.0.0"
PORT = 8888
ADDR = (HOST,PORT)

# 数据库链接 (父进程)
db = Database()

# 处理注册
def do_register(connfd,name,passwd):
    if db.register(name,passwd):
        connfd.send(b'OK')
    else:
        connfd.send(b'FAIL')

# 处理登录
def do_login(connfd,name,passwd):
    if db.login(name,passwd):
        connfd.send(b'OK')
    else:
        connfd.send(b'FAIL')

# 处理查询单次
def do_query(connfd,name,word):
    db.insert_history(name,word) # 插入历史记录

    mean = db.query(word) # 返回单词解释
    connfd.send(mean.encode())

# 历史记录
def do_history(connfd,name):
    # data ->((name,word,time),(),())
    data = db.history(name)
    for i in data:
        # i-->(name,word,time)
        msg = "%s    %s   %s"%i
        connfd.send(msg.encode())
        sleep(0.1) # 防止粘包
    connfd.send(b'##')  # 历史记录发送完了


# 处理客户端请求
def handle(connfd):
    # 在各自子进程中创建游标,方式相互影响
    db.create_cursor()
    # 循环接收请求,分情况讨论
    while True:
        data = connfd.recv(1024).decode()
        tmp = data.split(' ')
        if not data or tmp[0] == 'E':
            # 客户端退出,结束子进程
            break
        elif tmp[0] == "R":
            # tmp --> [R,name,passwd]
            do_register(connfd,tmp[1],tmp[2])
        elif tmp[0] == "L":
            # tmp --> [L,name,passwd]
            do_login(connfd,tmp[1],tmp[2])
        elif tmp[0] == 'Q':
            # tmp --> [Q,name,word]
            do_query(connfd,tmp[1],tmp[2])
        elif tmp[0] == 'H':
            # tmp --> [H,name]
            do_history(connfd,tmp[1])
    # 关闭这个 进程对应的游标 和 连接套接字
    db.cur.close()
    connfd.close()

# 启动函数,搭建网络
def main():
    # 创建tcp 套接字
    sockfd = socket()
    sockfd.bind(ADDR)
    sockfd.listen(5)

    # 处理僵尸
    signal(SIGCHLD,SIG_IGN)

    print("Listen the port %d"%PORT)
    while True:
        try:
            connfd,addr = sockfd.accept()
            print("Connect from ",addr)
        except KeyboardInterrupt:
            sockfd.close()
            db.close() # 关闭数据库
            sys.exit("服务端退出")

        # 为客户端创建新的进程
        p = Process(target=handle,args=(connfd,))
        p.daemon = True
        p.start()

if __name__ == '__main__':
    main()
```



###### 11.3  dict_client

```python
"""
dict 客户端

* 发起请求
* 获取数据进行展示
"""

from socket import *
import sys

# 服务端地址
ADDR = ("127.0.0.1",8888)

# 发起注册
def do_register(sockfd):
    while True:
        name = input("Name:")
        passwd = input("Password:")

        if ' ' in name or ' ' in passwd:
            print("用户名或者密码不许有空格")
            continue

        passwd_ = input("Again:")
        if passwd != passwd_:
            print("两次密码不一致")
            continue

        # 发送请求
        msg = "R %s %s"%(name,passwd)
        sockfd.send(msg.encode())
        # 等待反馈
        result = sockfd.recv(128).decode()
        if result == 'OK':
            print("注册成功")
        else:
            print("注册失败")
        return

# 发起登录
def do_login(sockfd):
    name = input("Name:")
    passwd = input("Password:")

    # 发送请求
    msg = "L %s %s"%(name,passwd)
    sockfd.send(msg.encode())
    # 等待反馈
    result = sockfd.recv(128).decode()
    if result == 'OK':
        print("登录成功")
        login(sockfd,name) # 登录成功的情况下进入二级界面
    else:
        print("登录失败")

# 查单次
def do_query(sockfd,name):
    while True:
        word = input("单词:")
        if word == '##':
            break
        msg = "Q %s %s"%(name,word)
        sockfd.send(msg.encode())
        # 接收结果 查到了接收解释 查不到接收Not Found
        result = sockfd.recv(1024).decode()
        print("%s : %s"%(word,result))

# 查历史记录
def do_history(sockfd,name):
    msg = "H "+name
    sockfd.send(msg.encode())
    # 客户端无法确定历史记录数量
    while True:
        # 每次接收一条历史记录
        data = sockfd.recv(1024).decode()
        if data == '##':
            break
        print(data)

# 二级界面   处于登录状态 xxx登录了
def login(sockfd,name):
    while True:
        print("""
        =========== 查词界面 ============
         1.查单词   2.历史记录   3.注销
        ======================= 用户:%s ==
        """%name)
        cmd = input("请输入命令:")
        if cmd == "1":
            do_query(sockfd,name)
        elif cmd == "2":
            do_history(sockfd,name)
        elif cmd == "3":
            break
        else:
            print("请输入正确指令")

# 启动函数
def main():
    # 创建套接字
    sockfd = socket()
    sockfd.connect(ADDR)

    # 一级界面
    while True:
        print("""
        ======== 登录界面 =========
         1.注册   2.登录   3.退出
        ==========================
        """)
        cmd = input("请输入命令:")
        if cmd == "1":
            do_register(sockfd)
        elif cmd == "2":
            do_login(sockfd)
        elif cmd == "3":
            sockfd.send(b"E")
            sys.exit("谢谢使用")
        else:
            print("请输入正确指令")

if __name__ == '__main__':
    main()
```



###### 11.4 dict_db

```python
"""
dict 数据库处理模块

* 根据 服务端在处理过程中的需求 进行数据的处理
"""
import pymysql

class Database:
    def __init__(self):
        self.db = pymysql.connect(
            host = 'localhost',
            port = 3306,
            user = 'root',
            password = '123456',
            database = 'dict',
            charset = 'utf8')

    def create_cursor(self):
        self.cur = self.db.cursor()

    def close(self):
        # 关闭
        self.db.close()

    ########  根据服务端需求写函数 #######
    def register(self,name,passwd):
        sql = "select name from user where name=%s;"
        self.cur.execute(sql,[name])
        r = self.cur.fetchone() # (name,) ()
        if r:
            return False # 不允许注册

        # 插入该用户
        sql = "insert into user (name,passwd) values (%s,%s);"
        try:
            self.cur.execute(sql,[name,passwd])
            self.db.commit()
            return True # 注册了 用户
        except:
            self.db.rollback()
            return False

    def login(self,name,passwd):
        sql = "select name from user where binary name=%s and passwd=%s;"
        self.cur.execute(sql, [name,passwd])
        r = self.cur.fetchone()  # (name,) ()
        # 如果能够查询到则可以登录
        if r:
            return True
        else:
            return False

    def query(self,word):
        sql = "select mean from words where word=%s;"
        self.cur.execute(sql,[word])
        r = self.cur.fetchone() # 可能查询不到 (mean,)
        if r:
            return r[0]
        else:
            # 没有查到
            return "Not Found"

    def insert_history(self,name,word):
        sql="select id from user where name=%s;"
        self.cur.execute(sql,[name])
        # 获取这个用户的id值
        user_id = self.cur.fetchone()[0]

        # 插入历史记录
        sql = "insert into hist (word,user_id) values (%s,%s);"
        try:
            self.cur.execute(sql,[word,user_id])
            self.db.commit()
        except:
            self.db.rollback()

    def history(self,name):
        # name  word  time
        sql = "select name,word,time " \
              "from user left join hist " \
              "on user.id = hist.user_id " \
              "where name=%s " \
              "order by time desc " \
              "limit 10;"
        self.cur.execute(sql,[name])
        # ((name,word,time),(),())
        return self.cur.fetchall()

```

